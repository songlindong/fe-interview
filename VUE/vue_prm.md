## vue进阶使用
### 特征一：模板化
#### 插槽 - slot => 考察点：以对比的形式存在
##### 默认插槽
* 面试点 => 默认插槽的实现方式 => 多个插槽聚合（插槽合并为同一个node节点）

* 问题 => 多个插槽节点希望分开布局 => 孩子区分节点的需求

##### 具名插槽
以name标识插槽的身份，从而在组件内部做到可区分
* 面试点 => name起到了区分不同传入节点的作用
=> name其实索引了一段解析上下文的空间

* 参数如何跟随节点传递 => 参数作用域父子隔离

##### 作用域插槽
外部做结构描述勾勒，内部做传参
* 孩子参数向父亲的slot结构中塞入
=> 父亲的参数向孩子的slot传递，应该如何做呢？

#### 模板的二次加工
1. watch | computed
=> a. 使用上的区别
=> b. 原理上 上游到下游的处理 初始化数据的计算逻辑 => 业务的逻辑处理 / 数据逻辑处理的
=> 影响面

2. 方案一：函数 - 独立、过滤器（管道符）=> 管道符拿不到实例this

方案二：v-html => 安全性

#### jsx 更自由的all in js
jsx语法 + 解析编译原理(render函数原理)
vue的编译路径：template => render() => vm.render()


### 特征二：模块化 / 组件化
```js
 Vue.component('component', {
    template: '<h1>我是组件</h1>'
 })
 new Vue({
    el: '#app'
 })
```
* 1. 抽象复用
* 2. 精简 & 聚合

#### 混入mixin - 逻辑混入
* 1. 应用：抽离公共逻辑（逻辑相同，模板不同，可用mixin）
* 2. 面试题：mixin的生命周期以及参数优先级
=> 合并策略
   1. 变量会补充
   2. 无论是变量还是生命周期，主应用后跑，主应用优先级更高

#### 继承拓展extends - 逻辑上的共用拓展
* 1. 应用：核心逻辑的功能继承
* 2. 合并策略
    1. 变量会补充
    2. 不论是业务代码还是mixin都在extend之后执行
grid-layout- 拖拽仓库

#### 多种方案
Vue.extend
Vue.use