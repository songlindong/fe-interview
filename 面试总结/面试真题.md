1. 
<!-- 
    用 css 实现如下的多列布局（类似九宫格，右下角为空）效果：
    父元素宽度自适应所在容器宽度，高度由子元素撑开，有不定数量的直接子元素（可以用8个演示），
    每一行排3 个子元素，子元素之间的水平、垂直间距为 10px ，
    子元素的宽度自适应父元素的宽度（(父元素宽度 - 10px * 2) / 3），
    子元素的高度与自身的宽度成正比（比如 2:1 ）
-->
2. 
<!-- 
const p1 = new Promise((resolve, reject) => {
    console.log(1)
    resolve('success')
    setTimeout(() => {
        console.log('2')
        reject('fail')
    })
})

console.log(3)

setTimeout(() => {
  console.log(4)
}, 100)

console.log(5)

setTimeout(() => {
    console.log(6)
})

const p2 = p1.then(res => {
    console.log(res)
    setTimeout(() => {
        console.log(7)
    }, 0)
    return res
}, error => {
    console.log(error)
    return error
})

console.log(p1)
console.log(p2)
console.log(p2 === p1)
 -->
3. 
<!-- 实现 (1).add(3).minus(2) 功能 -->
```js
 Number.prototype.add = function (value) {
    const number = parseFloat(value)
    if(typeof number !== 'number' || Number.isNaN(number)) {
        throw Error('请输入Number类型的数字或字符串')
    }

    return this + value
 }
 Number.prototype.minus = function (value) {
    const number = parseFloat(value)
    if(typeof number !== 'number' || Number.isNaN(number)) {
        throw Error('请输入Number类型的数字或字符串')
    }

    return this - value
 }
 console.log((1).add(3).minus(2))
```
4. 
<!-- 实现一个对象 Task，链式调用
new Task().sleep(3).log(1).sleep(1).sleep(2).log(2) -->
```js
class Person {
    constructor() {
        this.list = [];
        setTimeout(() => {
            this.next();
        })
    }
    talk(str) {
        console.log('talk函数')
        const fn = () => {
             console.log(str);
             this.next()
        }
        this.list.push(fn)
        return this
    }

    sleep(milsec) {
        console.log('sleep函数')
        const fn = () => {
            setTimeout(() => {
                console.log('get up')
                this.next()
            }, milsec)
        }

        this.list.push(fn)
        return this
    }

    next() {
        console.log('2222')
        console.log(this.list)
        const fn = this.list.shift()
        fn&&fn()
    }
}

const person = new Person()
person.talk("hello").sleep(3000).talk('world')
```
5. 
<!-- 
// - 两个栈模拟队列 可以数组来写，数组只能用 push，pop 方法。实现队列的 push\pop

//     1. [1, 2, 3, 4]

//     2. push(5) [1, 2, 3, 4, 5]

//     3. pop() [2, 3, 4, 5]

//     4. pop() [3, 4, 5]

//     5. push(6) [3, 4, 5, 6]
 -->
6. 
<!-- 
    实现一个批量请求函数
    function sendRequests(urls, max, callback) {
    }
    要求：
    urls为请求接口list
    可控制最大并发数，即max
    请求全部结束后，调用callback函数，传入排序好的请求结果list
    备注：
    发请求可以直接使用fetch API
    fetch(url).then()
 -->
7. 
<!-- 
// let asyncPool = [p1, p2, p3, ..p10];
// let asyncNum = 3;
// ret = [r1, r2, r3, ..r10];
// 尽可能利用并发量
 -->
8. 
<!-- 
/* 不使用async await 实现一个函数createFlow,使得以下代码输出方式如下：

// 延迟1s

1

2

// 延迟3s

3

4

*/

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const log = console.log

createFlow([

() => delay(1000).then(() => log(1)),

() => log(2),

() => delay(3000).then(() => log(3)),

() => log(4),

])
 -->
9. 
<!-- 
实现一个树状模板嵌套的处理，include标签也会包含一堆html标签以及include标签
let str = '<div><include path="./item.tpl" /></div>'
要求写一个函数，将树状嵌套的子模板都解析好替换

item.tpl 6
<div>6</div>

item.tpl

<include path="./item-sub.tpl" />
item-sub.tpl world

<div><span>hello</span>world</div>
 -->
```js
function parseTemplate(template) {
  const includeTag = /<include.+?path="(.+?)".*?\/>/g;
  let result = template.replace(includeTag, (match, path) => {
    const subTemplate = fs.readFileSync(path, { encoding: "utf8" });
    return parseTemplate(subTemplate);
  });
  return result;
}
```
10. 
<!-- 
岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

示例 1:
输入:
11110
11010
11000
00000
输出: 1

示例 2:
输入:
11000
11000
00100
00011
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
 -->
11. 
<!-- 
JavaScript 实现找出字符串中第一个没重复的字符

function getOnceChar(str) {
	const map = {};

	for (let i = 0; i < str.length; i++) {
		if (!map[str[i]] && str.indexOf(str[i], i + 1) === -1) {
			return str[i];
		}

		map[str[i]] = true;
	}
}
getOnceChar('aaaabbbcddcerr'); // e
 -->
12. 
```js
let arr = []
for (let i=0; i < 10; i++) {
    arr[i] = function() {
        return i
    }
}

console.log(arr[3]())

```