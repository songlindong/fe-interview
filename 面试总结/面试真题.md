1. 
<!-- 
    用 css 实现如下的多列布局（类似九宫格，右下角为空）效果：
    父元素宽度自适应所在容器宽度，高度由子元素撑开，有不定数量的直接子元素（可以用8个演示），
    每一行排3 个子元素，子元素之间的水平、垂直间距为 10px ，
    子元素的宽度自适应父元素的宽度（(父元素宽度 - 10px * 2) / 3），
    子元素的高度与自身的宽度成正比（比如 2:1 ）
-->
2. 
<!-- 
const p1 = new Promise((resolve, reject) => {
    console.log(1)
    resolve('success')
    setTimeout(() => {
        console.log('2')
        reject('fail')
    })
})

console.log(3)

setTimeout(() => {
  console.log(4)
}, 100)

console.log(5)

setTimeout(() => {
    console.log(6)
})

const p2 = p1.then(res => {
    console.log(res)
    setTimeout(() => {
        console.log(7)
    }, 0)
    return res
}, error => {
    console.log(error)
    return error
})

console.log(p1)
console.log(p2)
console.log(p2 === p1)
 -->
3. 
<!-- 实现 (1).add(3).minus(2) 功能 -->
4. 
<!-- 实现一个对象 Task，链式调用
new Task().sleep(3).log(1).sleep(1).sleep(2).log(2) -->
5. 
<!-- 
// - 两个栈模拟队列 可以数组来写，数组只能用 push，pop 方法。实现队列的 push\pop

//     1. [1, 2, 3, 4]

//     2. push(5) [1, 2, 3, 4, 5]

//     3. pop() [2, 3, 4, 5]

//     4. pop() [3, 4, 5]

//     5. push(6) [3, 4, 5, 6]
 -->
6.
<!-- 
    实现一个批量请求函数
    function sendRequests(urls, max, callback) {
    }
    要求：
    urls为请求接口list
    可控制最大并发数，即max
    请求全部结束后，调用callback函数，传入排序好的请求结果list
    备注：
    发请求可以直接使用fetch API
    fetch(url).then()
 -->